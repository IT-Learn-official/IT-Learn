{
  "chapterId": "chapter_14",
  "kind": "assessment",
  "title": "Chapter 14 – Comprehensions, map, filter, and zip Checkpoint",
  "description": "Quick concept-check for chapter 14. Test your understanding of list/set/dict comprehensions, map, filter, and zip.",
  "questions": [
    {
      "id": "q-list-comp-squares",
      "type": "single-choice",
      "prompt": "Which list comprehension correctly creates a list of squares of numbers in nums?",
      "options": [
        { "id": "a", "label": "squares = [n ** 2 for n in nums]", "isCorrect": true },
        { "id": "b", "label": "squares = (n ** 2 in nums)", "isCorrect": false },
        { "id": "c", "label": "squares = [nums for n in nums ** 2]", "isCorrect": false },
        { "id": "d", "label": "squares = n ** 2 for n in nums", "isCorrect": false }
      ],
      "explanations": {
        "overview": "List comprehensions use the pattern [expression for item in iterable].",
        "byOptionId": {
          "a": "Correct – this is the proper list comprehension syntax.",
          "b": "This creates a boolean expression, not a list.",
          "c": "The parts are in the wrong order and nums is used incorrectly.",
          "d": "Missing square brackets, so it is not a list comprehension."
        }
      }
    },
    {
      "id": "q-list-comp-filter",
      "type": "single-choice",
      "prompt": "What is the result of this code? nums = [1, 2, 3, 4, 5]; result = [n for n in nums if n % 2 == 0]",
      "options": [
        { "id": "a", "label": "[1, 3, 5]", "isCorrect": false },
        { "id": "b", "label": "[2, 4]", "isCorrect": true },
        { "id": "c", "label": "[0, 0, 0, 0, 0]", "isCorrect": false },
        { "id": "d", "label": "[(1, 2), (3, 4), (5,)]", "isCorrect": false }
      ],
      "explanations": {
        "overview": "The comprehension keeps only even numbers from nums.",
        "byOptionId": {
          "a": "These are the odd numbers, not the evens.",
          "b": "Correct – 2 and 4 are the even numbers.",
          "c": "Nothing in the code turns values into zeros.",
          "d": "This structure does not match the list comprehension at all."
        }
      }
    },
    {
      "id": "q-set-comp-unique",
      "type": "single-choice",
      "prompt": "What is the main difference between a list comprehension and a set comprehension?",
      "options": [
        { "id": "a", "label": "Set comprehensions can only contain numbers.", "isCorrect": false },
        { "id": "b", "label": "Set comprehensions automatically remove duplicate values.", "isCorrect": true },
        { "id": "c", "label": "Set comprehensions are always faster than list comprehensions.", "isCorrect": false },
        { "id": "d", "label": "Set comprehensions cannot use if conditions.", "isCorrect": false }
      ],
      "explanations": {
        "overview": "Sets keep only unique elements, while lists can have duplicates.",
        "byOptionId": {
          "a": "Sets can store many types, not just numbers.",
          "b": "Correct – sets automatically drop duplicates.",
          "c": "Speed depends on the situation; this is not always true.",
          "d": "You can use if conditions in set comprehensions too."
        }
      }
    },
    {
      "id": "q-zip-shortest",
      "type": "single-choice",
      "prompt": "What does list(zip([1, 2, 3], ['a', 'b'])) produce?",
      "options": [
        { "id": "a", "label": "[(1, 'a'), (2, 'b'), (3, None)]", "isCorrect": false },
        { "id": "b", "label": "[(1, 'a'), (2, 'b')]", "isCorrect": true },
        { "id": "c", "label": "[(1, 2, 3, 'a', 'b')]", "isCorrect": false },
        { "id": "d", "label": "[1, 2, 3, 'a', 'b']", "isCorrect": false }
      ],
      "explanations": {
        "overview": "zip stops when the shortest input is exhausted.",
        "byOptionId": {
          "a": "zip does not automatically fill with None.",
          "b": "Correct – only two pairs can be formed.",
          "c": "This would be a single tuple of all elements, which is not what zip does.",
          "d": "This is just a flat list, not pairs."
        }
      }
    },
    {
      "id": "q-map-vs-comp",
      "type": "single-choice",
      "prompt": "Which two expressions are most similar in what they do?",
      "options": [
        { "id": "a", "label": "list(map(str.upper, names)) and [name.upper() for name in names]", "isCorrect": true },
        { "id": "b", "label": "list(filter(str.upper, names)) and [name.upper() for name in names]", "isCorrect": false },
        { "id": "c", "label": "list(map(str.upper, names)) and names.upper()", "isCorrect": false },
        { "id": "d", "label": "[name for name in names] and [len(name) for name in names]", "isCorrect": false }
      ],
      "explanations": {
        "overview": "map applies a function to each element, just like a simple transformation comprehension.",
        "byOptionId": {
          "a": "Correct – both apply upper() to each element in names.",
          "b": "filter is for keeping some items, not transforming all of them.",
          "c": "names.upper() would not work on a list; upper() is a string method.",
          "d": "These comprehensions do different things (identity vs length)."
        }
      }
    }
  ]
}

